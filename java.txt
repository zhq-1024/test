java api帮助文档 https://docs.oracle.com/javase/8/docs/api/
=========================================================
progrom FilesX86 	32位
progrom Files  		64位
.bak				备份文件
软件：系统软件、应用软件
	系统软件：与硬件交互的软件
	应用软件：不与硬件交互，在系统软件的环境中运行
最基本的windows相关的DOS命令：
	exit 	退出当前dos命令窗口
	cls  	清屏
	dos窗口中的复制操作 右键标记，选中内容再右键，就可以进行粘贴
	dir		列出当前目录下所有的子目录
	cd		切换目录   change directory 使用方式：cd 目录的路径
	清楚相对路径和绝对路径
	cd .. 回到上级目录
	cd \  回到根目录
	切换盘符直接输入盘符即可 e:f:
关于windows操作系统的设置
	隐藏扩展名，熟悉文件扩展名的设置 计算机-》组织-》文件夹和搜索选项-》查看-》隐藏已知文件类型的扩展名
计算机语言发展史
	与计算机沟通的语言称之为计算机语言。人为制定好的一套交流规则
	第一代语言：机器语言	二进制编码	打孔机是代表
	第二代语言：低级语言	汇编语言为代表
	第三代语言：高级语言	c语言 C++ java
java
	1995年诞生
	jdk Java开发工具包        
	jvm 下载jdk时工具包里会有对应操作系统的jvm
	jdk下载时提示的版本指的时jvm的版本，java代码都是相同的
	java的可移植性指的就是jvm
java的加载与执行
	java运行的两个阶段  编译->运行
	编译:
		磁盘上的.java文件(源文件)是不能直接放到jvm中运行的
		只有编译成.class文件(字节码文件)才能放到jvm中运行
		在编译阶段时会检查java源程序是否符合java语法，不符合java语法则无法生成字节码文件
		编译时使用的是jdk中的javac.exe执行的，称java编译器
	运行：
		运行时使用jdk中的java.exe执行的，称java运行器
		java.exe用于启动jvm，jvm启动会启动类加载器，
		类加载器会去硬盘上搜索对应的类字节码文件
		找到后装载到jvm中，然后将字节码文件解释成二进制代码，让操作系统去执行从而实现与硬件平台的交互
		jre是运行环境
字符编码
	编码和解码采用同一套字典/对照表(ASCII码)，是二进制和显示文字的一个字典，由计算机协会制定的
	如果不是同一套字典，即采用的不是同一套规则，就有可能出现编码
java类型转换
	整型：	小容器转大容器，可以自动转换，称自动类型转换
			大容器转小容器，不可自动转换，称强制类型转换
			注意：强转有时候可能会损失精度，而且相当严重
			注意：大容器转小容器时，如果大容器的数值没有超出小容器的范围，可以自动强转(即不需要加强制转换符)，此时精度没有受损失
java.math.BigDecimal
		double的精度用于财务软件来说相对还是非常低的，sun公司为了解决这一问题，提出了一种更高精度的引用数据类型BigDecimal
		java中所有的浮点型字面值，都被当作double类型来处理
		java中所有的整形字面值，都被当作int类型来处理
java this的使用
		1.只用于实例对象，this代表实例对象的引用
		2.this大部分时候都是可以省略的，当传参和类的变量重名时，this不可省略
		3.this()调用的是构造方法，是构造方法调用的一个简写
java中的静态变量
		静态变量在类加载的时候就开始在方法区中开辟空间了，只执行一次
		当所有对象使用的一个属性，且属性值都一样时，声明静态变量
		当所有的对象里面的属性相互独立时，声明实例变量
dos操作
	Win+R 打开dos命令窗口
	cls 清屏
	dir 查看当前目录下的文件
	exit 退出当前dos命令窗口
	cd .. 回到上级目录
	cd / 回到根目录
	. 一个点，代表当前目录
	del 删除文件，不能删除文件夹
	ipconfig chakan ip地址（相当于电话号码）
instanceof运算符
	1.避免多态中向下转型时ClassCastException异常的发生
	2.instanceof返回类型结果为true或false
	3.用于条件判断  	对象引用 instanceof 类名
			返回结果 true；false；
===================================================
javaSE进阶
接口中的成员：
	常量(由于接口中的属性都是常量，所以接口中省略了public static final)
	抽象方法(由于接口中的方法都是抽象方法，所以接口中省略了public abstract)
匿名内部类
	内部类：在类的内部又定义了一个新的类，被称为内部类
	使用static修饰的内部类叫静态内部类
	不适用static修饰的内部类叫实例内部类
	局部内部类(类作为局部变量)和匿名内部类(接口方法重写作为参数的一种匿名形式)
idea中纠正错误的快捷键是Alt+Enter
==============================================================
java日期处理
	java Date 时间显示为外国格式 为了方便中国人看，需转成字符串
	simpleDateFormat类
		format()方法 	将Date转换成String		显示使用
		parse()方法	将String转换成Date		入数据库时使用
	获取自1970年1月1日 00:00:00到当前时间的总毫秒数
		System.currentTimeMills()   用途：用于统计一个方法所执行的时长
	扩展 数字格式化
		DecimalFormat 	
		BigDecimal	sun公司为解决财务数据计算提供的一个高精度引用类型
==============================================================
java枚举  
	枚举是一种引用数据类型，编译后生成class文件 枚举中的每一个值可以看成常量
	enum Result{枚举值1，枚举值2...}  
	enum Result{RED，BLUE，YELLOW}
	返回结果如果只有两种情况，建议使用boolean，如果返回结果超过两种，枚举非常适合使用
==============================================================
异常 try catch throws throw finally
1.什么是异常？异常机制有什么用？
	程序中执行过程中发生了不正常的情况，而这种不正常的情况叫做异常
	异常处理机制将异常打印出来，供程序员参考，方便程序维护
java的异常处理机制
	UML是一种统一建模语言，一种图标式语言。
	在UML图中可以描述类与类之间的关系，程序执行的流程，对象的状态等
	java语言中对异常处理的两种方式
		1.在方法声明的位置上，使用throws关键字，抛给上一级
		2.使用try...catch语句进行异常的捕捉
	上报 throws
	捕捉 try catch  
	抛出 throw 
	对于控制台打印的异常追踪信息，应从上往下看，注意，sun公司打印的异常追踪信息不需要去看
关于try...catch中的finally子句
	在finally子句中的代码时最后执行的，并且一定会执行，即使try语句的代码中出现了异常
	finally子句必须喝try一起出席那，不能单独编写	
	finally的作用：当try块中出现异常时，try后面的语句将不会执行，但又有一些是必须要执行的，比如说流的关闭，此时就必须使用finally去关闭
自定义异常
	自定义异常类继承异常类，类中只有一个无参构造和有参构造，跟源码一样
子类抛出的异常只能比父类的小，或者不抛
============================================================
集合
	集合：数据的载体
	集合存储的是内存地址，是一种引用类型
	不同的集合对应不同的数据结构(数组、链表、哈希表、二叉树)
java集合分为两大类：
	单个方式存储元素	java.util.Collection
	键值对方式存储元素	java.util.Map
Interable 可迭代的，可遍历的，所有的集合元素都是可遍历的，迭代的意思就是遍历的意思
	Collection接口 实现了 Interable 接口
	Interator 迭代器 hashNext() next() remove() 与Collection是关联关系
	Collection接口下有List接口和Set接口
		List接口存储元素特点：存储的元素有下标，是有序可重复的
		Set接口存储元素特点：存储的元素无下标，是无序不可重复的
	List接口中有常用类ArrayList、LinkedList、Vector
		ArrayList 		数组结构		非线程安全
		LinkedList 	双向链表
		Vector		数组结构		线程安全，使用较少
	Set接口中的常用类HashSet、TreeSet
		HashSet在new的时候，底层创建了一个HashMap，hash表数据结构
		TreeSet在new的时候，底层创建了一个HashTree，二叉树数据结构
	
	Map接口---->HashMap、HashTable、SortedMap接口
	SortedMap接口----> TreeMap
		HashMap		哈希表 非线程安全
		HashTable	哈希表 线程安全
Collection接口中的常用方法
	IsEmpty()		判断集合中元素是否为空 
	iterator() 		迭代方法，返回一个迭代器Iterator对象
			Iterator中有两个方法
				hashNext() 判断迭代器中是否存在下一个元素 返回true或false
				next() 这个方法让迭代器前进一位,返回当前元素
				Iterator it = Collection.iterator()
				it.hashNext() ? it.next() : ''
				while(it.hashNext()){显示 it.next()}
	contains()
=================================================
IO流中的序列化和反序列化
在序列化中，类需要实现一个序列化接口，这个接口起标志作用，会帮这个类自动生成一个序列化版本号
transient 游离的 由它修饰的类城远不会参与序列化	
序列化版本号是用来区分类的
=======================================================
反射机制
	1.反射机制的作用：
		通过java的反射机制可以操作字节码文件
		通过反射机制可以操作代码片段
	2.反射机制的相关类在哪个包下？
		java.lang.refect.*
	3.反射机制相关重要的类有哪些？
		java.lang.Class		代表字节码文件
		java.lang.reflect.Method	代表字节码中的方法字节码
		java.lang.reflect.Constructor	代表字节码中的构造方法字节码
		java.lang.reflect.Field	代表字节码文件中的属性字节码
=========================================================
要操作字节码中的代码片段，首先要获取类的字节码文件，获取类的字节码有三种方式
	注意：字节码文件在jvm中只有一个
	1.Class.forName("java.lang.String")
		forName()  静态方法、参数是完整类名(带包名的类名)
	2.对象.getClass()
		老祖先Object中有一个getClass方法，所以每一个方法中都会有一个getClass方法
	3.类名.class
==========================================================
反射机制创建对象(字节码文件创建对象)
	newInstance() 底层调用了类的无参构造方法，类中没有无参构造会报错，此方法已被淘汰 
===========================================================
类路径
	src目录下的路径是类路径，src是项目的根目录
获取绝对路径
	Thread.currentThread() 当前线程对象
	getContextClassLoader() 线程对象的方法，用于获取当前线程的类加载器对象
	getResource() 获取资源 类加载器的方法，从当前线程的类加载器中加载资源(从根目录src下进行搜索)
	getPath() 获取资源的绝对路径
	String path = Thread.currentThread().getContextClassLoader().getResource("相对路径").getPath()
资源绑定器
	ResourceBundle
类加载器
	jdk中自带的类加载器(加载字节码文件)
		专门负责加载类的命令/工具
		启动类加载器
		扩展类加载器
		应用类加载器
==========================================================
java.lang.reflect.Field	代表字节码文件中的属性字节码
java.lang.reflect.Field类中的常用方法
	getFields() 	只能获取类中public修饰的属性集合，返回结果是数组
	getDeclareFields() 	获取类中的所有属性集合
	以上两个方法得到的都是属性对象
	属性对象的常用方法
		getType 	获取属性对象的类型(所以返回类型是Class，比如String类型)
	类中的方法
		getName
		getSingleName
利用反射机制获取类的接口和父类
	Class c = Class.forName("完整类名")
	Class superClass = c.getSuperClass()   //获取父类
	Class[] interfaces = c.getInterfaces()    //获取接口
==========================================================
可变长度参数
	int... args		这就是可变长度参数，要求的个数是0~n个
	可变长度参数必须在参数列表的最后一位，而且参数列表中只能存在一个可变长度参数
	可变长度参数可以当作一个数组来看待
============================================================
注解
	注解，或者叫做注释 Annotation
	注解Annotation是一种引用数据类型，编译之后生成字节码文件
	注解的定义和语法格式
		【修饰符列表】@interface 注解类型名{}
	注解的使用
		@注解类型名
	注解出现的地方
		注解上、类上、属性上、方法上、变量上等......
==========================================================
jdk内置了哪些注解
	Deprecated 
		1.表示已过时
	Override
		1.只能注解方法
		2.供编译器参考的，和运行没有关系，用于编译检查，重写父类方法，又称标识性注解
	SuppressWarning
==========================================================
元注解
	修饰注解的注解叫做元注解，即用来标注"注解类型"的注解叫做元注解
	常见的元注解有哪些？
		Target	标注被标注的注解可以出现的那些位置上
			@Target(ElementType.METHOD) 
				表示被标注的注解只能出现在方法上
		Retention	标注被标注的注解最终保存在哪里
			@Retention(RetentionPolicy.SOURCE)
				表示该注解只被保存在java源文件中
			@Retention(RetentionPolicy.CLASS)
				表示该注解只被保存在class文件中
			@Retention(RetentionPolicy.RUNTIME)
				表示该注解只被保存在class文件中，并且可以被反射机制读取
==============================================================
注解中的属性
	声明，类似于类中的方法
	String name() default 默认值 		注解中的属性
	如果没有默认值，使用注解时必须给属性赋值
	例如 String name()   使用注解给属性赋值  @注解类型名(name = "zhangsan")
=============================================================
注解中的属性只有一个属性是value时，value才能省略
	String value()
	使用注解时value可以省略不写  比如 @注解类型名("haha")
				相当于 @注解类型名(value = "haha")	
=======================================================
注解中的属性可以有哪些类型？
	byte short int long float double boolean String Class 枚举
	以及以上每一种的数组形式
==========================================================
Github
	目的：借助github托管项目代码
Git基本概念
	仓库(Repository):用来存放开源项目，每一个项目对应一个仓库
	收藏(Star) 每一个仓库里有一个start按钮，收藏项目，方便下次观看
	复制克隆项目 (Fork)
	发起请求(pull request) 
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	